export AWS_DEFAULT_REGION=ap-southeast-5
export AWS_REGION=ap-southeast-5

aws-help() {
    echo "AWS Helper Functions"
    echo "==================="
    echo
    echo "Profile Management:"
    echo "  aws-profile [name]        Switch AWS profiles or list available profiles"
    echo
    echo "EC2 Operations:"
    echo "  aws-ec2-list             List all EC2 instances with details"
    echo "  aws-select-instance      Interactively select a running EC2 instance"
    echo "  aws-ssh                  SSH into EC2 instance via Session Manager"
    echo ""
    echo "Auto Scaling:"
    echo "  aws-asg-refresh          Start instance refresh for an Auto Scaling Group"
    echo
    echo "File Transfer:"
    echo "  aws-scp <src> <dest>     Transfer files via SSH over Session Manager (fast)"
    echo "  aws-scp-ssm <src> <dest> Transfer files via SSM commands (fallback)"
    echo
    echo "Database Operations:"
    echo "  aws-rds-info             Retrieve RDS credentials from Secrets Manager"
    echo "  aws-db-fwdport [port]    Port forward to RDS through EC2 via SSM"
    echo
    echo "Utility:"
    echo "  aws-help                 Show this help message"
    echo
    echo "Environment Variables:"
    echo "  AWS_PROFILE              Current AWS profile (managed by aws-profile)"
    echo "  AWS_RDS_SECRET_ID        Path to RDS credentials in Secrets Manager"
    echo
    echo "All commands automatically display the current AWS profile and prompt"
    echo "you to select one if none is set."
}

aws-profile() {
    if [ -z "$1" ]; then
        echo "Current profile: ${AWS_PROFILE:-<not set>}"
        echo "Available profiles:"
        aws configure list-profiles
        return
    fi

    export AWS_PROFILE=$1
    echo "Switched to AWS profile: $AWS_PROFILE"
}

_check_aws_profile() {
    echo "AWS Profile: ${AWS_PROFILE:-<not set>}" >&2

    if [ -z "$AWS_PROFILE" ]; then
        echo "No AWS profile is currently set." >&2
        echo "Available profiles:" >&2
        local profiles=$(aws configure list-profiles 2>/dev/null)

        if [ -z "$profiles" ]; then
            echo "Error: No AWS profiles found. Please run 'aws configure' to set up a profile." >&2
            return 1
        fi

        local counter=1
        local profile_array=()

        # Build array and display in the same loop to ensure order consistency
        while IFS= read -r profile; do
            # Skip empty lines
            if [ -n "$profile" ]; then
                profile_array+=("$profile")
                echo "$counter) $profile" >&2
                ((counter++))
            fi
        done <<< "$profiles"

        echo >&2
        printf "Select profile number (1-$((counter-1))): " >&2
        read selection </dev/tty

        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt $((counter-1)) ]; then
            echo "Invalid selection." >&2
            return 1
        fi

        local selected_profile="${profile_array[$selection]}"
        export AWS_PROFILE="$selected_profile"
        echo "Selected AWS profile: $AWS_PROFILE" >&2
    fi

    echo >&2
}

aws-rds-info(){
    _check_aws_profile || return 1

    if [ -z "$AWS_RDS_SECRET_ID" ]; then
        echo "Error: AWS_RDS_SECRET_ID environment variable is not set."
        echo "Please set it to your RDS secret path, e.g.:"
        echo "  export AWS_RDS_SECRET_ID=\"myapp/database/password\""
        return 1
    fi

    echo "Using secret: $AWS_RDS_SECRET_ID"
    aws secretsmanager get-secret-value \
        --secret-id "$AWS_RDS_SECRET_ID" \
        --query SecretString --output text | jq .
}

aws-ec2-list() {
    _check_aws_profile || return 1

    AWS_PAGER="" aws ec2 describe-instances \
        --query 'Reservations[*].Instances[*].[InstanceId,Tags[?Key==`Name`].Value|[0],State.Name]' \
        --output table
}

aws-select-instance() {
    _check_aws_profile || return 1

    local filter_state="${1:-running}"

    echo "Fetching $filter_state EC2 instances..." >&2

    # Get instances with their details
    local instances=$(aws ec2 describe-instances \
        --filters "Name=instance-state-name,Values=$filter_state" \
        --query 'Reservations[*].Instances[*].[InstanceId,Tags[?Key==`Name`].Value|[0],PrivateIpAddress,PublicIpAddress]' \
        --output text | grep -v "None\tNone\tNone")

    if [ -z "$instances" ]; then
        echo "No $filter_state EC2 instances found." >&2
        return 1
    fi

    echo "Available $filter_state EC2 instances:" >&2
    echo "=====================================" >&2

    local counter=1
    local instance_ids=()

    while IFS=$'\t' read -r instance_id name private_ip public_ip; do
        local display_name="${name:-"(no name)"}"
        local ip_info="Private: $private_ip"
        if [ "$public_ip" != "None" ] && [ -n "$public_ip" ]; then
            ip_info="$ip_info, Public: $public_ip"
        fi
        echo "$counter) $instance_id - $display_name - $ip_info" >&2
        instance_ids+=("$instance_id")
        ((counter++))
    done <<< "$instances"

    echo >&2
    printf "Select instance number (1-$((counter-1))): " >&2
    read selection </dev/tty

    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt $((counter-1)) ]; then
        echo "Invalid selection." >&2
        return 1
    fi

    echo "${instance_ids[$selection]}"
}

aws-db-fwdport() {
    local local_port="${1:-33060}"
    local rds_host="$2"
    local remote_port="3306"

    # If no RDS host provided, fetch from Secrets Manager
    if [ -z "$rds_host" ]; then
        _check_aws_profile || return 1

        if [ -z "$AWS_RDS_SECRET_ID" ]; then
            echo "Error: AWS_RDS_SECRET_ID environment variable is not set."
            echo "Please set it to your RDS secret path, or provide RDS host manually:"
            echo "  export AWS_RDS_SECRET_ID=\"myapp/database/password\""
            echo "  aws-db-fwdport [local-port] <rds-endpoint>"
            return 1
        fi

        echo "Fetching RDS endpoint from Secrets Manager..."
        echo "Using secret: $AWS_RDS_SECRET_ID"
        rds_host=$(aws secretsmanager get-secret-value \
            --secret-id "$AWS_RDS_SECRET_ID" \
            --query SecretString --output text | jq -r '.host // .endpoint // empty')

        if [ -z "$rds_host" ] || [ "$rds_host" = "null" ]; then
            echo "Error: Could not fetch RDS endpoint from Secrets Manager."
            echo "Please provide RDS host manually: aws-db-fwdport [local-port] <rds-endpoint>"
            return 1
        fi

        # Remove port if present (e.g., hostname:3306 -> hostname)
        rds_host="${rds_host%:*}"
        echo "Found RDS endpoint: $rds_host"
    fi

    local selected_instance=$(aws-select-instance)
    if [ $? -ne 0 ] || [ -z "$selected_instance" ]; then
        return 1
    fi

    echo "Starting port forwarding session..."
    echo "Instance: $selected_instance"
    echo "RDS Host: $rds_host"
    echo "Remote Port: $remote_port -> Local Port: $local_port"
    echo

    aws ssm start-session \
        --target "$selected_instance" \
        --document-name AWS-StartPortForwardingSessionToRemoteHost \
        --parameters "{\"host\":[\"$rds_host\"],\"portNumber\":[\"$remote_port\"],\"localPortNumber\":[\"$local_port\"]}"
}

aws-ssh() {
    _check_aws_profile || return 1

    local selected_instance=$(aws-select-instance)
    if [ $? -ne 0 ] || [ -z "$selected_instance" ]; then
        return 1
    fi

    echo "Connecting to instance: $selected_instance"
    echo "Starting SSH session via AWS Session Manager..."

    aws ssm start-session \
        --target "$selected_instance"
}

aws-scp-ssm() {
    if [ $# -lt 2 ]; then
        echo "Usage: aws-scp-ssm <source> <destination>"
        echo ""
        echo "Examples:"
        echo "  aws-scp ./config.json /opt/app/config/         # Upload relative local file"
        echo "  aws-scp /home/user/file.txt /remote/path/      # Upload absolute local file"
        echo "  aws-scp /var/log/app.log ./logs/               # Download to relative local path"
        echo "  aws-scp /remote/file.txt /home/user/           # Download to absolute local path"
        echo ""
        echo "Notes:"
        echo "  - Local paths can be relative or absolute"
        echo "  - Remote paths must be absolute (start with /)"
        echo "  - Transfer direction auto-detected based on path types"
        return 1
    fi

    _check_aws_profile || return 1

    local source="$1"
    local destination="$2"

    local selected_instance=$(aws-select-instance)
    if [ $? -ne 0 ] || [ -z "$selected_instance" ]; then
        return 1
    fi

    echo "Selected instance: $selected_instance"
    echo ""

    # Auto-detect transfer direction based on which path is absolute (remote)
    local is_upload=false
    local local_path=""
    local remote_path=""

    if [[ "$source" == /* ]] && [[ "$destination" != /* ]]; then
        # Source is absolute (remote), destination is local - DOWNLOAD
        is_upload=false
        remote_path="$source"
        local_path="$destination"
    elif [[ "$source" != /* ]] && [[ "$destination" == /* ]]; then
        # Source is local, destination is absolute (remote) - UPLOAD
        is_upload=true
        local_path="$source"
        remote_path="$destination"

        # If remote path ends with /, append filename
        if [[ "$remote_path" == */ ]]; then
            local filename=$(basename "$local_path")
            remote_path="${remote_path}${filename}"
        fi
    elif [[ "$source" == /* ]] && [[ "$destination" == /* ]]; then
        # Both absolute - ambiguous, ask user
        echo "Both paths are absolute. Specify transfer direction:"
        echo "1) Upload: $source → instance:$destination"
        echo "2) Download: instance:$source → $destination"
        echo -n "Select direction (1-2): " >&2
        read direction </dev/tty

        case $direction in
            1)
                is_upload=true
                local_path="$source"
                remote_path="$destination"
                # If remote path ends with /, append filename
                if [[ "$remote_path" == */ ]]; then
                    local filename=$(basename "$local_path")
                    remote_path="${remote_path}${filename}"
                fi
                ;;
            2)
                is_upload=false
                remote_path="$source"
                local_path="$destination"
                ;;
            *)
                echo "Invalid selection."
                return 1
                ;;
        esac
    else
        # Both relative - error
        echo "Error: At least one path must be absolute to identify remote location."
        echo "Remote paths must start with '/'"
        return 1
    fi

    # Convert relative local path to absolute if needed
    if [[ "$local_path" != /* ]]; then
        local_path="$(pwd)/$local_path"
    fi

    if [ "$is_upload" = true ]; then
        echo "Uploading $local_path to $selected_instance:$remote_path"

        # Encode file content as base64 to handle binary files and avoid shell issues
        local encoded_content=$(base64 -i "$local_path")

        # Upload via SSM send-command with smaller chunks for large files
        if [ ${#encoded_content} -gt 30000 ]; then
            echo "File is large ($(wc -c < "$local_path") bytes), this may take a moment..."
        fi

        # Create the file and set proper permissions
        local command_id=$(aws ssm send-command \
            --instance-ids "$selected_instance" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"echo '$encoded_content' | base64 -d > '$remote_path' && echo 'File written successfully' || echo 'Failed to write file'\"]" \
            --query 'Command.CommandId' \
            --output text)

        if [ -n "$command_id" ]; then
            echo "Waiting for upload to complete..."

            # Wait with timeout
            if aws ssm wait command-executed \
                --command-id "$command_id" \
                --instance-id "$selected_instance" 2>/dev/null; then

                # Check command result
                local cmd_status=$(aws ssm get-command-invocation \
                    --command-id "$command_id" \
                    --instance-id "$selected_instance" \
                    --query 'Status' \
                    --output text)

                local cmd_output=$(aws ssm get-command-invocation \
                    --command-id "$command_id" \
                    --instance-id "$selected_instance" \
                    --query 'StandardOutputContent' \
                    --output text)

                local cmd_error=$(aws ssm get-command-invocation \
                    --command-id "$command_id" \
                    --instance-id "$selected_instance" \
                    --query 'StandardErrorContent' \
                    --output text)

                if [ "$cmd_status" = "Success" ] && [[ "$cmd_output" == *"File written successfully"* ]]; then
                    echo "Upload completed successfully."
                else
                    echo "Upload failed. Status: $cmd_status"
                    echo "Output: $cmd_output"
                    echo "Error: $cmd_error"
                    return 1
                fi
            else
                echo "Upload command timed out or failed to execute."
                return 1
            fi
        else
            echo "Failed to initiate upload command."
            return 1
        fi

    else
        echo "Downloading $selected_instance:$remote_path to $local_path"

        # Download via SSM send-command
        local command_id=$(aws ssm send-command \
            --instance-ids "$selected_instance" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"base64 '$remote_path'\"]" \
            --query 'Command.CommandId' \
            --output text)

        if [ -n "$command_id" ]; then
            echo "Waiting for download to complete..."
            aws ssm wait command-executed \
                --command-id "$command_id" \
                --instance-id "$selected_instance"

            # Check command status and get output
            local dl_status=$(aws ssm get-command-invocation \
                --command-id "$command_id" \
                --instance-id "$selected_instance" \
                --query 'Status' \
                --output text)

            if [ "$dl_status" = "Success" ]; then
                # Get the base64 encoded file content and decode it
                aws ssm get-command-invocation \
                    --command-id "$command_id" \
                    --instance-id "$selected_instance" \
                    --query 'StandardOutputContent' \
                    --output text | base64 -d > "$local_path"

                echo "Download completed successfully."
            else
                echo "Download failed. Status: $dl_status"
                # Show error details
                aws ssm get-command-invocation \
                    --command-id "$command_id" \
                    --instance-id "$selected_instance" \
                    --query 'StandardErrorContent' \
                    --output text
                return 1
            fi
        else
            echo "Failed to initiate download command."
            return 1
        fi
    fi
}

aws-scp() {
    if [ $# -lt 2 ]; then
        echo "Usage: aws-scp <source> <destination>"
        echo ""
        echo "Examples:"
        echo "  aws-scp ./config.json /opt/app/config/         # Upload to instance"
        echo "  aws-scp /var/log/app.log ./logs/               # Download from instance"
        echo ""
        echo "Notes:"
        echo "  - Uses SSH over Session Manager (faster than aws-scp-ssm)"
        echo "  - Requires SSH key configured on the instance"
        echo "  - Local paths can be relative or absolute"
        echo "  - Remote paths must be absolute (start with /)"
        return 1
    fi

    _check_aws_profile || return 1

    local source="$1"
    local destination="$2"
    local username="${3:-ubuntu}"  # Default to ubuntu, can override

    local selected_instance=$(aws-select-instance)
    if [ $? -ne 0 ] || [ -z "$selected_instance" ]; then
        return 1
    fi

    echo "Selected instance: $selected_instance"
    echo "Using SSH user: $username"
    echo ""

    # Auto-detect transfer direction and fix paths
    local is_upload=false
    local local_path=""
    local remote_path=""

    if [[ "$source" == /* ]] && [[ "$destination" != /* ]]; then
        # Download: remote → local
        is_upload=false
        remote_path="$source"
        local_path="$destination"
    elif [[ "$source" != /* ]] && [[ "$destination" == /* ]]; then
        # Upload: local → remote
        is_upload=true
        local_path="$source"
        remote_path="$destination"

        # If remote path ends with /, append filename
        if [[ "$remote_path" == */ ]]; then
            local filename=$(basename "$local_path")
            remote_path="${remote_path}${filename}"
        fi
    else
        echo "Error: One path must be absolute (remote) and one relative/absolute (local)"
        return 1
    fi

    # Convert relative local path to absolute
    if [[ "$local_path" != /* ]]; then
        local_path="$(pwd)/$local_path"
    fi

    # Setup SSH config for this session
    local ssh_config_backup=""
    if [ -f ~/.ssh/config ]; then
        ssh_config_backup=$(mktemp)
        cp ~/.ssh/config "$ssh_config_backup"
    fi

    # Add temporary SSH config for Session Manager proxy
    cat >> ~/.ssh/config << EOF

# Temporary AWS Session Manager proxy config
Host i-* mi-*
    ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p'"
    User $username
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
EOF

    echo "Setting up SSH proxy via Session Manager..."

    # Perform the transfer
    if [ "$is_upload" = true ]; then
        echo "Uploading $local_path to $selected_instance:$remote_path"
        scp "$local_path" "$selected_instance:$remote_path"
    else
        echo "Downloading $selected_instance:$remote_path to $local_path"
        scp "$selected_instance:$remote_path" "$local_path"
    fi

    local scp_result=$?

    # Restore original SSH config
    if [ -n "$ssh_config_backup" ]; then
        mv "$ssh_config_backup" ~/.ssh/config
    else
        # Remove the temporary config we added
        sed -i '/# Temporary AWS Session Manager proxy config/,$d' ~/.ssh/config
    fi

    if [ $scp_result -eq 0 ]; then
        echo "Transfer completed successfully."
    else
        echo "Transfer failed."
        return $scp_result
    fi
}

aws-asg-refresh() {
    _check_aws_profile || return 1

    echo "Fetching Auto Scaling Groups..." >&2

    # Get all ASGs
    local asgs=$(aws autoscaling describe-auto-scaling-groups \
        --query 'AutoScalingGroups[*].[AutoScalingGroupName,DesiredCapacity,MinSize,MaxSize]' \
        --output text)

    if [ -z "$asgs" ]; then
        echo "No Auto Scaling Groups found." >&2
        return 1
    fi

    echo "Available Auto Scaling Groups:" >&2
    echo "=============================" >&2

    local counter=1
    local asg_names=()

    while IFS=$'\t' read -r asg_name desired min_size max_size; do
        echo "$counter) $asg_name (Desired: $desired, Min: $min_size, Max: $max_size)" >&2
        asg_names+=("$asg_name")
        ((counter++))
    done <<< "$asgs"

    echo >&2
    printf "Select ASG number (1-$((counter-1))): " >&2
    read selection </dev/tty

    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt $((counter-1)) ]; then
        echo "Invalid selection." >&2
        return 1
    fi

    local selected_asg="${asg_names[$selection]}"

    echo "Selected ASG: $selected_asg" >&2
    echo "Starting instance refresh with MinHealthyPercentage=0, InstanceWarmup=0..." >&2
    echo "WARNING: This will cause downtime as MinHealthyPercentage=0" >&2
    echo -n "Continue? (y/N): " >&2
    read confirm </dev/tty

    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Cancelled." >&2
        return 1
    fi

    aws autoscaling start-instance-refresh \
        --auto-scaling-group-name "$selected_asg" \
        --preferences MinHealthyPercentage=0,InstanceWarmup=0

    if [ $? -eq 0 ]; then
        echo "Instance refresh started successfully for $selected_asg"
    else
        echo "Failed to start instance refresh"
        return 1
    fi
}
